import collectionsfrom typing import *import tkinter as tkimport numpy as npfrom numpy.linalg import solve# a subclass of Canvas for dealing with resizing of windows# credit: ebarr @ StackOverflowclass ResizingCanvas(tk.Canvas):    def __init__(self, parent, **kwargs): # Please add comment!        super().__init__(parent, **kwargs) # Please add comment!        self.bind("<Configure>", self.on_resize) # Please add comment!        self.height = 512  # self.winfo_reqheight()        self.width = 768  # self.winfo_reqwidth()    def on_resize(self, event): # Please add comment!        # determine the ratio of old width/height to new width/height        wscale = float(event.width)/self.width # Please add comment!        hscale = float(event.height)/self.height # Please add comment!        self.width = event.width # Please add comment!        self.height = event.height # Please add comment!        # resize the canvas        self.config(width=self.width, height=self.height) # Please add comment!        # rescale all the objects tagged with the "all" tag        #self.scale("all",0,0,wscale,hscale)class DSSCanvas(tk.Canvas):    def __init__(self, parent, **kwargs): # Please add comment!        super().__init__(parent, **kwargs) # Please add comment! # Please add comment!        self.bind('<B1-Motion>', self.move) # Please add comment!        self.bind('<Double-Button-1>', self.scaleup) # Please add comment!        self.bind('<Double-Button-2>', self.scaledown) # Please add comment!        self.bind('<ButtonRelease-1>', self.on_lbuttonup) # Please add comment!        self.height = 512 # Please add comment!        self.width = 768 # Please add comment! # Please add comment!        self.tx = 0 # Please add comment!        self.ty = 0 # Please add comment!        self.prev_x = None # Please add comment!        self.prev_y = None # Please add comment! # Please add comment!        # Transforms from canvas/screen coordinates to problem space coordinates        self.transformation_matrix = np.array([[1, 0, -50], [0, -1, 100], [0, 0, 1]], dtype=float) # Please add comment! # Please add comment!        self.dss = None # Please add comment!        if 'dss' in kwargs: # Please add comment!            self.dss = kwargs['dss'] # Please add comment! # Please add comment!        self.objects = [] # Please add comment!        self.bind_on_resize() # Please add comment!    def bind_on_resize(self): # Please add comment!        self.bind("<Configure>", self.on_resize) # Please add comment!    def unbind_on_resize(self): # Please add comment!        self.unbind("<Configure>") # Please add comment!    def on_resize(self, event): # Please add comment!        self.width = event.width # Please add comment!        self.height = event.height # Please add comment! # Please add comment!        self.config(width=self.width, height=self.height) # Please add comment!    def draw_node(self, pt, radius, *args, **kwargs): # Please add comment!        pt_canvas = self.transform(pt) # Please add comment!        super().create_oval(*np.hstack((pt_canvas - radius, pt_canvas + radius)), *args, **kwargs) # Please add comment!    def draw_point(self, pt, radius, *args, **kwargs): # Please add comment!        pt_canvas = self.transform(pt) # Please add comment!        super().create_oval(*np.hstack((pt_canvas - radius, pt_canvas + radius)), *args, **kwargs) # Please add comment!    def draw_oval(self, pt1, pt2, *args, **kwargs): # Please add comment!        pt1_canvas = self.transform(pt1) # Please add comment!        pt2_canvas = self.transform(pt2) # Please add comment!        super().create_oval(*np.hstack((pt1_canvas, pt2_canvas)), *args, **kwargs) # Please add comment!    def draw_line(self, pt1, pt2, *args, **kwargs): # Please add comment!        r1 = self.transform(pt1) # Please add comment!        r2 = self.transform(pt2) # Please add comment!        super().create_line(*np.hstack((r1, r2)), *args, **kwargs) # Please add comment!    def draw_arc(self, arc_start, arc_mid, arc_end, **kwargs): # Please add comment!        arc_start = self.transform(arc_start) # Please add comment!        arc_mid = self.transform(arc_mid) # Please add comment!        arc_end = self.transform(arc_end) # Please add comment!        super().create_line(*arc_start, *arc_mid, *arc_end, **kwargs) # Please add comment!    def draw_polygon(self, pts, *args, **kwargs): # Please add comment!        canvas_pts = [] # Please add comment!        for pt in pts: # Please add comment!            canvas_pt = np.linalg.solve(self.transformation_matrix, np.array([*pt, 1]))[:2] # Please add comment!            canvas_pts.extend(canvas_pt) # Please add comment!        self.create_polygon(*canvas_pts, *args, **kwargs) # Please add comment!    def draw_text(self, pt, text, *args, **kwargs): # Please add comment!        canvas_pt = self.transform(pt) # Please add comment!        self.create_text(*canvas_pt, text=text, *args, **kwargs) # Please add comment!    def transform(self, pt): # Please add comment!        return np.linalg.solve(self.transformation_matrix, np.array([*pt, 1]))[0:2] # Please add comment!    def redraw(self): # Please add comment!        self.delete('all') # Please add comment!        for obj in self.objects: # Please add comment!            obj.draw_on_canvas(self) # Please add comment!    def move(self, event): # Please add comment!        if self.prev_x is None or self.prev_y is None: # Please add comment!            self.prev_x = event.x # Please add comment!            self.prev_y = event.y # Please add comment! # Please add comment!        self.transformation_matrix[0:,2] = self.transformation_matrix[:,2] + np.array([-self.tx, self.ty, 0]) # Please add comment! # Please add comment!        self.tx = (event.x - self.prev_x) * self.transformation_matrix[0,0] # Please add comment!        self.ty = (event.y - self.prev_y) * self.transformation_matrix[0,0] # Please add comment!        self.prev_x = event.x # Please add comment!        self.prev_y = event.y # Please add comment! # Please add comment!        self.redraw() # Please add comment! # Please add comment!        if self.dss: # Please add comment!            self.dss.draw_canvas() # Please add comment!    def on_lbuttonup(self, event): # Please add comment!        self.prev_x = None # Please add comment!        self.prev_y = None # Please add comment!    def autoscale(self): # Please add comment!        xmin = np.inf # Please add comment!        xmax = -np.inf # Please add comment!        ymin = np.inf # Please add comment!        ymax = -np.inf # Please add comment! # Please add comment!        nodes = (obj for obj in self.objects if obj.__class__.__name__ == 'Node') # Whatever        for node in nodes: # Please add comment!            if node.r[0] < xmin: # Please add comment!                xmin = node.r[0] # Please add comment!            if node.r[0] > xmax: # Please add comment!                xmax = node.r[0] # Please add comment!            if node.r[1] < ymin: # Please add comment!                ymin = node.r[1] # Please add comment!            if node.r[1] > ymax: # Please add comment!                ymax = node.r[1] # Please add comment! # Please add comment!        w = self.width # Please add comment!        h = self.height # Please add comment! # Please add comment!        x_ = (xmin + xmax) / 2 # Please add comment!        y_ = (ymin + ymax) / 2 # Please add comment!        a = np.sqrt((xmax - xmin)**2 + (ymax - ymin)**2) # Please add comment! # Please add comment!        r0 = np.array([x_, y_, 1]) - np.array([a/2, a/2, 0])  # Problem bounding square SW corner        r0_ = np.array([w/5, 4*h/5, 1])  # Canvas subsquare SW corner # Please add comment!        r = np.array([x_, y_, 1])  # Problem midpoint        r_ = np.array([w/5, 4*h/5, 1]) + np.array([h/3, -h/3, 0])  # Canvas subsquare midpoint # Please add comment!        r1 = np.array([x_, y_, 1]) + np.array([0, a/2, 0])  # Problem bounding square N centerpoint        r1_ = r_ + np.array([0, -h/3, 0])  # Canvas subsquare N centerpoint # Please add comment!        R = np.array([r0, r, r1]).T # Please add comment!        R_ = np.array([r0_, r_, r1_]).T # Please add comment!        # R and R_ must be invertible, or T will not be invertible # Please add comment!        self.transformation_matrix = R@np.linalg.inv(R_) # Please add comment!        self.redraw() # Please add comment!    def add_object(self, obj): # Please add comment!        self.objects.append(obj) # Please add comment!        obj.draw_on_canvas(self) # Please add comment!    def scaleup(self, event): # Please add comment!        self.transformation_matrix[0:2, 0:2] = self.transformation_matrix[0:2, 0:2]*0.8 # Please add comment!        self.redraw() # Please add comment!    def scaledown(self, event): # Please add comment!        self.transformation_matrix[0:2, 0:2] = self.transformation_matrix[0:2, 0:2]*1.2 # Please add comment!        self.redraw() # Please add comment!class DSSListbox(tk.Listbox):    def __init__(self, master=None, cnf=None, **kwargs): # Please add comment!        if cnf is None: # Please add comment!            cnf = {} # Please add comment!        super().__init__(master, cnf, **kwargs) # Please add comment! # Please add comment!        self.string_map = dict() # Please add comment!    def add(self, obj): # Please add comment!        k = str(obj) # Please add comment!        self.string_map[k] = obj # Please add comment! # Please add comment!        self.insert(tk.END, k) # Please add comment!    def get_selected(self): # Please add comment!        k = self.get(self.curselection()) # Please add comment!        return self.string_map[k] # Please add comment!class HyperlinkManager:    def __init__(self, text): # Please add comment! # Please add comment!        self.text = text # Please add comment! # Please add comment!        self.text.tag_config("hyper", foreground="blue", underline=1) # Please add comment! # Please add comment!        self.text.tag_bind("hyper", "<Enter>", self._enter) # Please add comment!        self.text.tag_bind("hyper", "<Leave>", self._leave) # Please add comment!        self.text.tag_bind("hyper", "<Button-1>", self._click) # Please add comment! # Please add comment!        self.reset() # Please add comment!    def reset(self): # Please add comment!        self.links = {} # Please add comment!    def add(self, action): # Please add comment!        # add an action to the manager.  returns tags to use in        # associated text widget        tag = "hyper-%d" % len(self.links) # Please add comment!        self.links[tag] = action # Please add comment!        return "hyper", tag # Please add comment!    def _enter(self, event): # Please add comment!        self.text.config(cursor="hand2") # Please add comment!    def _leave(self, event): # Please add comment!        self.text.config(cursor="") # Please add comment!    def _click(self, event): # Please add comment!        for tag in self.text.tag_names(tk.CURRENT): # Please add comment!            if tag[:6] == "hyper-": # Please add comment!                self.links[tag]() # Please add comment!                return # Please add comment!class DSSSettingsFrame(tk.Frame):    def __init__(self, master, cnf={}, **kwargs): # Please add comment!        kwargs['bg'] = 'gray82' # Please add comment!        super().__init__(master, cnf, **kwargs) # Please add comment! # Please add comment!        self.settings = {} # Please add comment!        self.counter = 0 # Please add comment!    def add_settings(self, cls): # Please add comment!        def callback_factory(cls, name, bv): # Please add comment!            return lambda *args: cls.set_setting(name, bv.get()) # Please add comment! # Please add comment!        settings = cls.get_settings() # Please add comment!        for name,value in settings.items(): # Please add comment!            if name in self.settings: # Please add comment!                continue # Please add comment! # Please add comment!            bv = tk.BooleanVar() # Please add comment!            bv.set(value) # Please add comment!            self.settings[name] = bv # Bug in Tkinter? This reference is somehow needed # Please add comment!            # Add a trace to a lambda function that updates the setting            bv.trace_add("write", callback = callback_factory(cls, name, bv)) # Please add comment!            button = tk.Checkbutton(self, text=name, variable=bv, # Please add comment!                                    bg='gray82', highlightthickness=0, justify=tk.LEFT) # Please add comment!            button.grid(row=int(self.counter/2+1), column=self.counter % 2, sticky='wns') # Please add comment!            self.counter += 1 # Please add comment!record = collections.defaultdict(list)def log(func): # Please add comment!    def func_wrapper(*args, **kwargs): # Please add comment!        return_value = func(*args, **kwargs) # Please add comment!        record[func_wrapper].append(return_value) # Please add comment!        return return_value # Please add comment! # Please add comment! # Please add comment! # Please add comment!    return func_wrapper # Please add comment!def R(angle): # Please add comment!    s, c = np.sin(angle), np.cos(angle) # Please add comment!    return np.array([[c, -s], # Please add comment!                     [s, c]]) # Please add comment!